#requires -version 3
<#
.SYNOPSIS
  Update BTDF Project file
.DESCRIPTION
  During each build, the BTDF Project file needs to have the version and guid renewed.  This uses the version generated by GitVersion on TFS.
.PARAMETER <Parameter_Name>
    <Brief description of parameter input required. Repeat this attribute if required>
.INPUTS
  .btdfproj file
.OUTPUTS
  .btdfproj file is updated
.NOTES
  Version:        1.0
  Author:         Richard Nunez
  Creation Date:  January 9, 2018
  Purpose/Change: Initial script development
  
.EXAMPLE
  .\UpdateDeploymentProjectFile.ps1
#>
[cmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [string]$ProjectFile,

    [Parameter(Mandatory=$true)]
    [string]$MethodOfVersionNumber="GitVersion",

    [string]$VersionNumberEnvVar,
    [boolean]$CombinePatchBuildNumbers=$true
)

# Method to extract Version Number
# $MethodOfVersionNumber = Can be "GitVersion", "Environment", "BuildNumber", or "DateTime"


Function Get-VersionNumber($InputString)
{
  Write-Host "String to Parse version number: $($InputString)"
  $VersionRegex = "\d+\.\d+\.\d+\.\d+|\d+\.\d+\.\d+"
  $VersionData = [regex]::matches($InputString,$VersionRegex)
  Write-Host "Matched Regex: $($VersionData.Count)"
  If($VersionData.Count -gt 0)
  {
    $parsedVersionNumber = $VersionData[0]
    Write-Host "parsedVersionNumber: $parsedVersionNumber"

    return $parsedVersionNumber
  }
  else {
    Write-Host "Did not extract version number from string: $($InputString)"
    return ""
  }
}

Function Combine-PatchBuildNumbers($UnformattedVersionNumber) {
  $tmpMajor = 0
  $tmpMinor = 0
  $tmpPatch = 0
  $tmpBuild = 0

  $VersionRegex2 = "(\d+)\.(\d+)\.(\d+)\.(\d+)|(\d+)\.(\d+)\.(\d+)"
  $VersionData = [regex]::matches($UnformattedVersionNumber,$VersionRegex2)
  $MatchedGroups = $VersionData[0].Groups

  if($MatchedGroups[1].Success -And $MatchedGroups[1].Length -gt 0) { $tmpMajor = $MatchedGroups[1].Value }
  if($MatchedGroups[2].Success -And $MatchedGroups[2].Length -gt 0) { $tmpMinor = $MatchedGroups[2].Value }
  if($MatchedGroups[3].Success -And $MatchedGroups[3].Length -gt 0) { $tmpPatch = $MatchedGroups[3].Value }
  if($MatchedGroups[4].Success -And $MatchedGroups[4].Length -gt 0) { $tmpBuild = $MatchedGroups[4].Value }
  
  if($MatchedGroups[5].Success -And $MatchedGroups[5].Length -gt 0) { $tmpMajor = $MatchedGroups[5].Value }
  if($MatchedGroups[6].Success -And $MatchedGroups[6].Length -gt 0) { $tmpMinor = $MatchedGroups[6].Value }
  if($MatchedGroups[7].Success -And $MatchedGroups[7].Length -gt 0) { $tmpPatch = $MatchedGroups[7].Value }

  # Write-Host "tmpMajor = $tmpMajor"
  # Write-Host "tmpMinor = $tmpMinor"
  # Write-Host "tmpPatch = $tmpPatch"
  # Write-Host "tmpBuild = $tmpBuild"
  
  if ($tmpBuild -gt 0) {
    #$new_tmpPatch = "{0:00}" -f $tmpPatch
    #$new_tmpBuild = "{0:000}" -f $tmpBuild
    $tmpPatchPadding = 3 - $tmpPatch.length
    # Write-Host "tmpPatchPadding = $tmpPatchPadding"
    [string]$newtmpPatch = "{0:D$($tmpPatchPadding)}" -f $tmpPatch

    $tmpBuildPadding = 4 - $tmpPatch.length
    [string]$newtmpBuild = "{0:D$($tmpBuildPadding)}" -f $tmpBuild
    #"{0:D$tmpBuildPadding}" -f $tmpBuild

    Write-Host "newtmpPatch = $newtmpPatch"
    Write-Host "newtmpBuild = $newtmpBuild"

    [string]$newPatchBuild = [string]$newtmpPatch + [string]$newtmpBuild

    if ($newPatchBuild -gt 65535) {
      #Throw error because we are going to get an MSI compilation error, so fix it here first.
      Write-Error "Invalid Patch Number version '$($newPatchBuild)'. Patch Number must have a Patch version less than 65536."
    }


    Write-Host "About to use: $newPatchBuild"
    $FinalVersionNumber = "$($tmpMajor).$($tmpMinor).$($newPatchBuild)"
    Write-Host "About to return $FinalVersionNumber"
    return $FinalVersionNumber
  }
  else {
    # Do nothing since this is a clean released Major.Minor.Patch build with no prerelease Build Number.
    return $UnformattedVersionNumber
  }
}

$VersionNumber = "0.1.0"

If ( $MethodOfVersionNumber -eq "BuildNumber" ) {
  If (Test-Path Env:BUILD_BUILDNUMBER) {
    Write-Host "Setting version to value stored in: BUILD_BUILDNUMBER"
    $VersionNumber = Get-VersionNumber $Env:BUILD_BUILDNUMBER
    Write-Host "Found Version Number to use: $VersionNumber"
  } else {
    Write-Error "The environment variable BUILD_BUILDNUMBER was not found."
  }
}
elseif ( $MethodOfVersionNumber -eq "Environment" ) {
  if (Test-Path env:$($VersionNumberEnvVar) ) { 
    $VersionNumber = (get-item env:$VersionNumberEnvVar).Value
  } 
  else {
    Write-Error "The environment variable $($VersionNumberEnvVar) was not found."
  }
}
elseif ( $MethodOfVersionNumber -eq "GitVersion" ) {
  If (Test-Path Env:GITVERSION_SEMVER) {
    Write-Host "Setting version to value stored in: GITVERSION_MAJORMINORPATCH"
    $VersionNumber =  $Env:GITVERSION_MAJORMINORPATCH
    Write-Host "Git Version Number to use: $VersionNumber"
    if (-not ([string]::IsNullOrEmpty($Env:GITVERSION_COMMITSSINCEVERSIONSOURCE))) {
      Write-Host "Setting version to value stored in: GITVERSION_MAJORMINORPATCH and GITVERSION_COMMITSSINCEVERSIONSOURCE"
      $VersionNumber = "$($Env:GITVERSION_MAJORMINORPATCH)" + "." + "$($Env:GITVERSION_COMMITSSINCEVERSIONSOURCE)"
    }
  }
}
# elseif ( $MethodOfVersionNumber -eq "DateTime" ) {
#   # YYYY.MM.DD.HH.MM.Second
#   2359.59
# }

# ******************************************************
If ([string]::IsNullOrEmpty($VersionNumber)) {
  Write-Error "Version Number was not extracted."
} else {
  Write-Host "Extracted Version Number: $($VersionNumber)"
}

if ($CombinePatchBuildNumbers) {
  Write-Host "Combing the Path and Build Numbers."
  $VersionNumber = Combine-PatchBuildNumbers "$VersionNumber"
} else {
  Write-Host "Combining the Patch and Build Numbers was skipped!"
}

# Find Deployment.btdfproj
# Get-ChildItem -Path $SearchMask -Recurse # return array of results including Parameter_Name
#Get-ChildItem -Path $SearchBaseDir -File -Recurse -Filter "\src\*.btdfproj"
# if ((Get-ChildItem -Path $SearchBaseDir -File -Recurse -Filter "$ProjectFile").Count -gt 0) {
#   $ProjectFileToModify = (Get-ChildItem -Path $SearchBaseDir -File -Recurse -Filter "$ProjectFile" | Select -First 1).FullName
# }
$ProjectFileToModify = "$ProjectFile"
Write-Host "Trying to find $ProjectFile"
if (!(Test-Path "$ProjectFileToModify")) {
  Write-Error "Could not find BTDF Project file: $ProjectFileToModify"
}


Write-Host "Version Number to use: $VersionNumber"
Write-Host "Project file to modify: $ProjectFileToModify"

If(Test-Path "$ProjectFileToModify") {
  $FileContents = Get-Content "$ProjectFileToModify"
  $NewFileContents = $FileContents -replace '<ProductVersion>(.+?)<\/ProductVersion>',"<ProductVersion>$VersionNumber</ProductVersion>"
  $NewGuidToUse = [guid]::NewGuid()
  Write-Host "Guid to use: $NewGuidToUse"
  $NewFileContents2 = $NewFileContents -replace '<ProductId>(.+?)<\/ProductId>',"<ProductId>$NewGuidToUse</ProductId>"
  $NewFileContents2 | Set-Content -Path "$ProjectFileToModify"
}
